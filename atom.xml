<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ItchyHiker</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://itchyhiker.com/"/>
  <updated>2018-04-01T11:19:37.539Z</updated>
  <id>https://itchyhiker.com/</id>
  
  <author>
    <name>Vincent</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>建站工具</title>
    <link href="https://itchyhiker.com/%E5%BB%BA%E7%AB%99%E5%B7%A5%E5%85%B7/"/>
    <id>https://itchyhiker.com/建站工具/</id>
    <published>2018-04-01T11:18:10.000Z</published>
    <updated>2018-04-01T11:19:37.539Z</updated>
    
    <content type="html"><![CDATA[<h2 id="免费图床"><a href="#免费图床" class="headerlink" title="免费图床"></a>免费图床</h2><blockquote><p>图床一般指的是存储图片的服务，通过外链的方式显示图片，解决因为带宽小，图片打开慢的问题。</p></blockquote><center> <strong>以下推荐只针对海外站点</strong> </center><ol><li><a href="https://simimg.com/" target="_blank" rel="noopener">simimg.com</a>:免费10TB云存储图片空间, 单张最大支持10MB . 全球CDN加速, 支持外链。不需要注册，从2008年至今都稳定运行,支持https</li><li><a href="https://sm.ms/" target="_blank" rel="noopener">SM.MS</a>: 每张图片最大5M,而且每次最多上传 10 张图片。在法律允许范围内，请随意使用本图床。经测试，图床很稳，支持https，亲测可用。</li></ol><hr><center> 持续更新 </center>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;免费图床&quot;&gt;&lt;a href=&quot;#免费图床&quot; class=&quot;headerlink&quot; title=&quot;免费图床&quot;&gt;&lt;/a&gt;免费图床&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;图床一般指的是存储图片的服务，通过外链的方式显示图片，解决因为带宽小，图片打开慢的问题。&lt;/p&gt;

      
    
    </summary>
    
      <category term="Tools/Wheels" scheme="https://itchyhiker.com/categories/Tools-Wheels/"/>
    
    
      <category term="ItchyHiker.com" scheme="https://itchyhiker.com/tags/ItchyHiker-com/"/>
    
  </entry>
  
  <entry>
    <title>GPU-Related</title>
    <link href="https://itchyhiker.com/GPU-Related/"/>
    <id>https://itchyhiker.com/GPU-Related/</id>
    <published>2018-04-01T11:16:15.000Z</published>
    <updated>2018-04-01T11:17:36.459Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h2 id="Nvidia-Driver-Crupted"><a href="#Nvidia-Driver-Crupted" class="headerlink" title="Nvidia Driver Crupted"></a>Nvidia Driver Crupted</h2><p>跑了一晚上程序之后，回来电脑卡住，重启电脑，无法加载显卡驱动，无法使用独显，电脑分辨率降低, 运行nvidia-smi显示：</p><blockquote><p>NVIDIA-MSI has failded because it couldn’t communicate with the NVIDIA driver. Make use the latest driver is installed and running.<br>应该是强制关机后驱动损坏了，需要重新装下驱动。</p></blockquote><h3 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h3><ol><li>以前下载的驱动还在电脑里面 NVIDIA-375</li><li>Ctrl + Alt + F1 进入控制台</li><li>service lightdm stop</li><li>进入驱动所在路径</li><li><p>删除原有驱动</p><blockquote><p>sudo sh NVIDIA-Linux-x86-64.375.66.run –uninstall</p></blockquote></li><li><p>重装驱动</p><blockquote><p>sudo sh NVIDIA-Linux-x86-64.375.66.run</p></blockquote></li><li>reboot, 可以正常显示进入图形界面</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;Nvidia-Driver-Crupted&quot;&gt;&lt;a href=&quot;#Nvidia-Driver-Crupted&quot; class=&quot;headerlink&quot; title=&quot;Nvidia Driver Crupted&quot;&gt;&lt;/a&gt;Nvidi
      
    
    </summary>
    
      <category term="Tools/Wheels" scheme="https://itchyhiker.com/categories/Tools-Wheels/"/>
    
    
      <category term="Deep Learning" scheme="https://itchyhiker.com/tags/Deep-Learning/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 295 Find Medium from Data Stream</title>
    <link href="https://itchyhiker.com/LeetCode-295-md/"/>
    <id>https://itchyhiker.com/LeetCode-295-md/</id>
    <published>2018-04-01T11:07:49.000Z</published>
    <updated>2018-04-01T11:23:20.720Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题描述："><a href="#问题描述：" class="headerlink" title="问题描述："></a>问题描述：</h2><p>Median is the middle value in an ordered integer list. If the size of the list is even, there is no middle value. So the median is the mean of the two middle value.</p><p>Examples:<br>[2,3,4] , the median is 3</p><p>[2,3], the median is (2 + 3) / 2 = 2.5</p><p>Design a data structure that supports the following two operations:</p><ul><li>void addNum(int num) - Add a integer number from the data stream to the data structure.</li><li>double findMedian() - Return the median of all elements so far.</li></ul><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>如果容器中的数据是已经排序的，容器中数据为奇数时，中位数是最中间的数；容器中的数据是偶数时，为最中间两个数的平均值。<br>如果能够保证数据容器左边的数据都小于右边的数据，这样即使左右两边内部的数据没有排序，也可以根据<strong>左边最大的数</strong>和<strong>右边最小的数</strong>得到中位数。<strong>用最大推可以快速的从一个数据容器中找出最大数，最小堆可以快速的从一个数据容器中找出最小的数。</strong></p><p>首先动态维护一个最大堆和最小堆，同时保证：</p><ul><li>最大堆堆顶元素(最大)比最小堆堆顶元素(最小)要小</li><li>最大堆的元素个数小于或者等于最小堆元素个数</li><li>最大堆和最小堆元素总个数为偶数时:<ul><li>新加入值大于或等于最大堆的堆顶，push到最小堆</li><li>新加入值小于最大堆堆顶，将最大堆堆顶值push到最小堆，pop最大堆堆顶，将新值插入最大堆。</li></ul></li><li>最大堆和最小堆元素总个数为奇数时(<strong>此时最大堆元素个数应该小于最小堆元素个数</strong>)：<ul><li>新加入值小于等于最小堆堆顶，push到最大堆</li><li>新加入值大于最小堆堆顶，将最小堆堆顶值push到最大堆，pop最小堆堆顶，将新值插入到最小堆。</li></ul></li></ul><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MedianFinder</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    MedianFinder()&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addNum</span><span class="params">(<span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(small_queue.empty())&#123; <span class="comment">//保证最小堆中元素大于等于最大堆</span></span><br><span class="line">            small_queue.push(num);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(big_queue.size()==small_queue.size())&#123;</span><br><span class="line">            <span class="keyword">if</span>(num&gt;=big_queue.top())&#123;</span><br><span class="line">                small_queue.push(num);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                small_queue.push(big_queue.top());</span><br><span class="line">                big_queue.pop();</span><br><span class="line">                big_queue.push(num);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (big_queue.size() &lt; small_queue.size())&#123;</span><br><span class="line">            <span class="keyword">if</span>(num&lt;=small_queue.top())&#123;</span><br><span class="line">                big_queue.push(num);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                big_queue.push(small_queue.top());</span><br><span class="line">                small_queue.pop();</span><br><span class="line">                small_queue.push(num);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">findMedian</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">double</span> median;</span><br><span class="line">        <span class="keyword">if</span>(big_queue.size() == small_queue.size())&#123;</span><br><span class="line">            median = (big_queue.top()+small_queue.top())/<span class="number">2.0</span>; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            median=small_queue.top();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> median;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>: </span><br><span class="line">    <span class="built_in">std</span>::priority_queue&lt;<span class="keyword">int</span>, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;, <span class="built_in">std</span>::less&lt;<span class="keyword">int</span>&gt; &gt; big_queue; </span><br><span class="line">    <span class="built_in">std</span>::priority_queue&lt;<span class="keyword">int</span>, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;, <span class="built_in">std</span>::greater&lt;<span class="keyword">int</span>&gt; &gt; small_queue; </span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MedianFinder object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MedianFinder obj = new MedianFinder();</span></span><br><span class="line"><span class="comment"> * obj.addNum(num);</span></span><br><span class="line"><span class="comment"> * double param_2 = obj.findMedian();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h2 id="测试结果"><a href="#测试结果" class="headerlink" title="测试结果"></a>测试结果</h2><p><img src="https://s1.ax2x.com/2018/04/01/tRB09.png" alt="tRB09.png"><br>可以看出效果还是挺好的，LeetCode的一个优点是你可以在Detail里面看见那些比你效率更高或者是更低的代码，用来参考还是挺不错的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;问题描述：&quot;&gt;&lt;a href=&quot;#问题描述：&quot; class=&quot;headerlink&quot; title=&quot;问题描述：&quot;&gt;&lt;/a&gt;问题描述：&lt;/h2&gt;&lt;p&gt;Median is the middle value in an ordered integer list. If 
      
    
    </summary>
    
    
      <category term="LeetCode" scheme="https://itchyhiker.com/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 455 Assign Cookies</title>
    <link href="https://itchyhiker.com/LeetCode-455/"/>
    <id>https://itchyhiker.com/LeetCode-455/</id>
    <published>2018-04-01T11:05:50.000Z</published>
    <updated>2018-04-01T11:21:55.499Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>Assume you are an awesome parent and want to give your children some cookies. But, you should give each child at most one cookie. Each child i has a greed factor gi, which is the minimum size of a cookie that the child will be content with; and each cookie j has a size sj. If sj &gt;= gi, we can assign the cookie j to the child i, and the child i will be content. Your goal is to maximize the number of your content children and output the maximum number.</p><p><strong>Note:</strong><br>You may assume the greed factor is always positive.<br>You cannot assign more than one cookie to one child.<br><strong>Example 1:</strong></p><blockquote><p>Input: [1,2,3], [1,1]<br>Output: 1<br>Explanation: You have 3 children and 2 cookies. The greed factors of 3 children are 1, 2, 3.<br>And even though you have 2 cookies, since their size is both 1, you could only make the child whose greed factor is 1 content.<br>You need to output 1.</p></blockquote><p><strong>Example 2:</strong></p><blockquote><p>Input: [1,2], [1,2,3]<br>Output: 2<br>Explanation: You have 2 children and 3 cookies. The greed factors of 2 children are 1, 2.<br>You have 3 cookies and their sizes are big enough to gratify all of the children,<br>You need to output 2.</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>这道题的要求是满足最多的孩子，可以看做是一个动态规划的问题，可以使用贪心算法实现。<br>首先对孩子的greed factor和糖果的size从小到大排序，如果第一个糖果可以满足第一个孩子那么它被使用，保证每个糖果优先满足那些greed factor 最小的糖果，把greed factor留给后面size更大的糖果。</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findContentChildren</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp; g, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp; s)</span></span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::sort(g.begin(),g.end()); <span class="comment">//对孩子greed factor和糖果size排序</span></span><br><span class="line">        <span class="built_in">std</span>::sort(s.begin(), s.end());</span><br><span class="line">        <span class="keyword">int</span> child=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> cookie=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(cookie &lt; s.size() &amp;&amp; child &lt; g.size())&#123;</span><br><span class="line">            <span class="keyword">if</span>(g[child] &lt;= s[cookie])&#123;</span><br><span class="line">                child++;</span><br><span class="line">            &#125;</span><br><span class="line">            cookie++;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> child;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h2><p><img src="https://s1.ax2x.com/2018/04/01/tRf9d.png" alt="tRf9d.png"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;Assume you are an awesome parent and want to give your childre
      
    
    </summary>
    
      <category term="Data Structure/Algorithm" scheme="https://itchyhiker.com/categories/Data-Structure-Algorithm/"/>
    
    
      <category term="LeetCode" scheme="https://itchyhiker.com/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 215 Kth Largest Element in an Array</title>
    <link href="https://itchyhiker.com/LeetCode-251/"/>
    <id>https://itchyhiker.com/LeetCode-251/</id>
    <published>2018-04-01T11:03:16.000Z</published>
    <updated>2018-04-01T11:10:03.702Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>Find the kth largest element in an unsorted array. Note that it is the kth largest element in the sorted order, not the kth distinct element.<br>For example,<br>Given [3,2,1,5,6,4] and k = 2, return 5.</p><p>Note:<br>You may assume k is always valid, 1 ≤ k ≤ array’s length</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>需要找到第K个最大的值，可以使用最小堆实现，动态维护一个含有K个元素的最小堆。首先将array中前k个元素输入最小堆，然后从K+1个元素开始，将元素和最小堆的堆顶比较，大于堆顶的话，把最小堆堆顶元素pop()，push()新元素。array中元素全部比较完了之后，可以确定最小堆的堆顶元素就是Kth largest element. </p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findKthLargest</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i &lt; k)&#123;</span><br><span class="line">                small_queue.push(nums[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[i] &gt; small_queue.top())&#123;</span><br><span class="line">                small_queue.pop();</span><br><span class="line">                small_queue.push(nums[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> small_queue.top();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::priority_queue&lt;<span class="keyword">int</span>, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;, <span class="built_in">std</span>::greater&lt;<span class="keyword">int</span>&gt; &gt; small_queue; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h2><p><a href="https://simimg.com/i/tnFBq" target="_blank" rel="noopener"><img src="https://s1.ax2x.com/2018/04/01/tnFBq.md.png" alt="tnFBq.md.png"></a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;Find the kth largest element in an unsorted array. Note that i
      
    
    </summary>
    
      <category term="Data Structure/Algorithm" scheme="https://itchyhiker.com/categories/Data-Structure-Algorithm/"/>
    
    
      <category term="LeetCode" scheme="https://itchyhiker.com/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>The Economist A lose lose deal</title>
    <link href="https://itchyhiker.com/The-Economist-A-lost-lose-deal/"/>
    <id>https://itchyhiker.com/The-Economist-A-lost-lose-deal/</id>
    <published>2018-03-31T09:28:07.000Z</published>
    <updated>2018-03-31T09:28:07.461Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2><ol><li>目前虽然特朗普还没有发起贸易战争，但是他已经在到处对各国的钢铁和铝制品征收关税。日本和欧洲各国都在征求豁免权。</li><li>中国的表现更克制，认为两国应该寻求双赢的结果。作为美国的竞争对手，中国知道自己不可能从这次征收关税中幸免，不过对美国的钢铁和铝出口量只占占GDP的3%，不足一提。</li><li>中国担心的是另外两件事：<br>1) Trump要求中国将对美国的3750亿美元双边贸易额盈余减少1000亿美元。<br>2) Trump想就中国盗取美国公司秘密而制裁中国。他将对从中国进口的超过600亿美元的商品征收关税。这些商品主要是高科技产品和通信产品。</li><li>不久以前中国政府官员还以为他们已经摸清了特朗普的底细。在9月对中国的国事访问中签下了2500亿美元的贸易订单。</li><li>让中国减少1000亿美元的贸易顺差，这从技术层面而言是荒唐可笑的。</li><li>但是这项要求帮助中国理清了思路，他们需要让特朗普大赢一次。</li><li>但是如果美国对中国的知识产权采取严厉惩罚，中国的应对将会强硬的多。习近平会让外界知道自己不是好欺负的。</li><li>令人担忧的是，在贸易消耗战当中，中美双方都认为自己有优势。美国认为中国的贸易额大，损失也就大，中国认为自己对美国的贸易额占GDP的比重小。和中国一贯奉行的双赢宗旨相反，眼下的趋势极有可能试一次两败俱伤之战。</li></ol><h2 id="Vocabulary"><a href="#Vocabulary" class="headerlink" title="Vocabulary"></a>Vocabulary</h2><ul><li>placate: 抚慰，平息<ul><li>placebo: 安慰剂</li></ul></li><li>splutter: to speak quickly and with difficulty, making soft spitting sounds, because you are angry or embarassed.</li><li>reprieve: 缓刑，暂缓</li><li>retaliate: to do sth harmful to sb because they have harmed you first.</li><li>ostensible:　表面的，假装的，看得出的<br>  ＋<em>Ostensibly he was on a business trip, but he spent most of the time on the beach.</em></li><li>ostensibly: 显然, 外表，表面</li><li>glow: 1)send out light and heat without flame 2) be look or feel warm or red<ul><li><em>1) her glowing cheeks 2) a cigarate glowed in the dark</em>  </li></ul></li><li>asendancy: 优势，支配地位</li><li>hefty: 重的，肌肉发达的, big and heavy</li><li>in a pinch: 必要时，在紧要关头</li><li>have the making of sth:   to have the qualities or skills necessary to do a particular job, to become that thing.<ul><li><em>Godfrey had the makings of a successful journalist.</em></li></ul></li><li>bromide: 陈词滥调</li><li>lexicon：词汇词典</li><li></li><li>risible: 可笑的，荒唐的<ul><li><em>the entire proposal is risible, it will not be accepted</em></li></ul></li><li>have the meansure of someone: to form an opinion about sb’s character so that you can deal with them </li><li>in a pinch: 紧要关头</li><li>hawkish adviser: 鹰派幕僚</li><li>pushover: 容易做的工作，易被劝服的人，易被击败的人</li><li>stiff: firm and difficult to bend or move</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Summary&quot;&gt;&lt;a href=&quot;#Summary&quot; class=&quot;headerlink&quot; title=&quot;Summary&quot;&gt;&lt;/a&gt;Summary&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;目前虽然特朗普还没有发起贸易战争，但是他已经在到处对各国的钢铁和铝制品征收关税。日本和欧
      
    
    </summary>
    
      <category term="Language" scheme="https://itchyhiker.com/categories/Language/"/>
    
    
      <category term="English" scheme="https://itchyhiker.com/tags/English/"/>
    
      <category term="Economist" scheme="https://itchyhiker.com/tags/Economist/"/>
    
  </entry>
  
  <entry>
    <title>图像数据集大全</title>
    <link href="https://itchyhiker.com/Computer-Vision-Datasets/"/>
    <id>https://itchyhiker.com/Computer-Vision-Datasets/</id>
    <published>2018-03-31T07:16:45.000Z</published>
    <updated>2018-03-31T09:30:36.703Z</updated>
    
    <content type="html"><![CDATA[<p>记录自己常用的图片数据集<br><a id="more"></a></p><ol><li><a href="http://yann.lecun.com/exdb/mnist/" target="_blank" rel="noopener">MNIST</a>: 机器学习，深度学习，计算机视觉入门数据集(hello world级别)。0-9手写数字数据，包含60,000张28<em>28的二值训练图像，10,1000张28</em>28测试图像。</li><li><a href="http://www.cs.toronto.edu/~kriz/cifar.html" target="_blank" rel="noopener">CIFAR-10</a>: 10类物体数据集(airplane, automobile, bird, cat, deer, dog, frog, horse, ship, truck)，包含60,000张32<em>32</em>3的彩色图片，每类6000张。一共分为6个batch, 5个训练batch, 1个测试batch，每个batch 10,000张。</li><li><a href="http://lms.comp.nus.edu.sg/research/NUS-WIDE.htm" target="_blank" rel="noopener">NUS-WIDE</a>：新加坡国立大学 Lab for Media Search 创建的网络数据集，包括：1) 269,648 张采集自Flickr图片和5018个关联标签; 2) 从这些图片中提取的6种低级特征，64-D颜色直方图，73-D边缘直方图，128小波纹理， 255-D块方式颜色矩和基于SIFT描述的500-D 词汇包(bag od words) 3) 可用于评估的81个概念。这个数据集可以用来确定网络图像注释和检索的一些研究问题。还使用k-NN算法从标签数据学习来提供网络图像注释的基线结果。这些基础结果显示，可以从这些数据中学习以帮助进行一般的图像检索。</li><li><a href="http://www.vision.caltech.edu/Image_Datasets/Caltech101/" target="_blank" rel="noopener">CalTech101/256</a>: 101类物体数据集，每一类40-800张图片，大多数是每一类50张,每张图片大小大约是300*200。</li></ol><hr><p><a href="http://www.cvpapers.com/datasets.html" target="_blank" rel="noopener">CVPaper维护的数据集大全</a><br><a href="https://deeplearning4j.org/cn/opendata" target="_blank" rel="noopener">深度学习开放数据集</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;记录自己常用的图片数据集&lt;br&gt;
    
    </summary>
    
      <category term="Tools/Wheels" scheme="https://itchyhiker.com/categories/Tools-Wheels/"/>
    
    
      <category term="ComputerVision" scheme="https://itchyhiker.com/tags/ComputerVision/"/>
    
  </entry>
  
</feed>
